Доброго времени суток!

Задача 1. «Спуск в лабиринте»

Решение задачи располагается в папке task1. Для того чтобы проверить решение, в папке resources находятся файлы для входных
данных и для вывода результата.

Решение задания:

№1) По заданному моменту времени M начала движения шара определить, может ли он
докатиться до выхода, и сколько это займет времени.

Итак, запуск программы начинается с инициализации Maze - главный класс, в котором находится информация о пустых комнатах, стенах, входе,
выходе, лабиринте и т.д. А также в данном классе происходят основные операции по созданию и выводу лабиринта.
Сам лабиринт предстаставляется в виде двумерного массива maze
В конструкторе мы вызываем метод initializeMaze(), который инициализирует входные данные в maze.

Каждая комната имеет свои координаты в maze. Класс Coordinate нам поможет в отслеживании координат.

Далее, наша программа имеет "класс-помощник" Helper, который решает проблему нахождения пути от входа до выхода.
Для того чтобы найти путь, мы используем очередь (т.е. действуем по принципу FIFO), в которую заносится сначала
координаты входа в лабиринт.
В методе solve() действуем по следующему алгоритму:
в цикле (до тех пор пока элементы в очереди не закончатся) мы проверям:
-входят ли данные координаты в доступное расположенние( isValidLocation() ) и является ли комната с данными координатами
посещенной ( isVisited() )
-является ли данная комната стеной
-является ли данная комната выходом. Если да, то мы с помощью метода backPath() получаем список координат всего пути
-иначе мы с помощью DIRECTIONS добавляем соседей в очередь

После того как мы нашли путь который мяч должен преодолеть до выхода, мы вызываем метод printPath,
в который и передается найденный путь. Чтобы не повторяться и было нагляднее, реализация pringPath описана в методе

Итак, подводя итог, я не смог реализовать принцип гравитации, когда мячик скатывается в нижнюю по уровню комнату.

Но в целом, я думаю, мне удалось более или менее прорисовать лабиринт, найти путь от начала и до выхода,
реализовать принцип с закрывающимися и открывающимися перегородками.
В файле, содержащем результат, выводится лабиринт. Комнаты, в которых перегородка была открыта на момент, когда мячик
добрался до данной комнаты в N-й ход, я обозначил в лабиринте '\', закрывающиеся , соответсвенно, равны '|'.
Таким образом, если в лабиринте нет закрывающихся перегородок '|', тогда мяч должен дораться до выхода
минимум за 17 ходов, если же в определенный момент M в некоторой, рандомной комнате есть закрывающеяся перегородка,
то ходов, в зависимости от закр. перегородок, больше.

Фуууух, надеюсь понятно обяъснил свой алгоритм решения.


Задание 2. «Вопрос к знатокам Java»
Предположу, что большие объемы занимаемой памяти связаны с работой сборщика мусора. Во-первых, нет никаких гарантий, что
после вызова нами gc начнется сборка мусора. Garbage collector, грубо говоря, сам решает когда ему вызываться.
Во-вторых, сборщик мусора занимает определенный объем ресурсов процессора. В-третьих, проблема заключается в утечке в памяти,
когда на объект ссылается ссылка, но сам объект программе больше не нужен, поэтому gb не удаляет данный объект.

Также выдвину предположение о том, что исполняющая система Java занимает так много памяти из-за кроссплатформенности,
т.е. в отличие, например, от С++ (где программа на С++ сразу компилятором превращается в машинный код),
Java превращает программу в байт-код, а JVM превращает байт-код в команды процессора

