Доброго времени суток!

Задача 1. «Спуск в лабиринте»

Решение задачи располагается в папке task1. Для того, чтобы проверить решение в папке resources находятся файлы для входных
данных и для вывода результата.

Решение задания:

№1) По заданному моменту времени M начала движения шара определить, может ли он
докатиться до выхода, и сколько это займет времени.

Итак, запуск программы начинается с инициализации Maze - главный класс, в котором находится информация о пустых комнатах, стенах, входе,
выходе, лабиринте и т.д. А также в данном классе происходят основные операции по созданию и выводу лабиринта.
Сам лабиринт предстаставляет из двумерный массив maze
В конструкторе мы вызываем метод initializeMaze(), который инициализирует входные данные в maze.

Каждая команата имеет свои координаты в maze. Класс Coordinate нам поможет в отслеживании координат.

Далее наша программа имеет "класс-помощник" Helper, который решает проблему нахождения пути от входа до выхода.
Для того чтобы найти путь, мы используем очередь (т.е. действуем по принципу FIFO), в которую заносится сначала
координаты входа в лабиринт.
В методе solve() действуем по следующему алгоритму:
в цикле (до тех пор пока элементы в очереди не закончатся) мы проверям:
-входят ли данные координаты в доступное расположенние( isValidLocation() ) и является ли комната с данными координатами
посещенной ( isVisited() )
-является ли данная комната стеной
-является ли данная комната выходом. Если да, то мы с помощью метода backPath() мы список координат всего пути
-иначе мы с помощью DIRECTIONS добавляем соседей в очередь

После того как мы нашли путь который мяч должен преодолеть до выхода, мы вызываем метод printPath,
в который и передается найденный путь. Чтобы не повторяться и было нагляднее, реализация pringPath описана в методе

Итак, подводя итог, я не смог реализовать принцип гравитации, когда мячик скатывается в нижнюю по уровню комнату.

Но в целом, я думаю, более менее реализовать принцип с закрывающимися и открывающимися перегородками,
В файле, содержащий результат, выводится лабиринт. Комнаты, в которых перегородка была открыта на момент, когда мячик
добрался до данной комнаты в N-й ход, я обозначил в лабиринте '\', закрывающиеся , соответсвенно, равны '|'.
Таким образом, если в итоговом лабиринте нет закрывающихся перегородок '|', тогда мяч должен дораться до выхода
за 17 ходов, если же в определенный момент M в некоторой, рандомной комнате появилась закрывающеяся перегородка,
то ходов, в зависимости от закр. перегородок, больше.

Фуууух, надеюсь понятно обяъснил свой алгоритм решения.


Задание 2. «Вопрос к знатокам Java»
Предположу, что большие объемы занимаемой памяти связаны с работой сборщика мусора. Во-первых, нет никаких гарантий, что
после вызова нами gc начнется сборка мусора. Garbage collector, грубо говоря, сам решает когда ему вызываться.